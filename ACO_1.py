# -*- coding: utf-8 -*-
"""ACO.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uJdQX_JLgWFIc5T_mrem3VjI2MDngsv_
"""

import random as rndm
import math

countJob = int(input("How much jobs: "))
countProc = int(input("How much processor: "))

# Processing Time & Pheromone Matrix
PTPmatrix = []

# index dalam 1 job
index = 0

for i in range(countProc):
  # index untuk job dalam 1 processor
  indexIn = 0
  PTPmatrix.append([])
  while indexIn < countJob:
    PTPmatrix[i].append([])
    PTPmatrix[i][indexIn].insert(index, (math.ceil((rndm.random()) * 10)))
    PTPmatrix[i][indexIn].insert(index+1, 0.0)
    indexIn+=1

# value paling tinggi
minValue = 0

def globalUpdate(best_solution, pheromone_increase):
    i = 0
    # Increment pheromone levels on the edges (job assignments) of the best solution
    for processor_index in range(len(best_solution)):
        PTPmatrix[processor_index][i][1] += pheromone_increase
        i+=1

def updatePheromone(list_of_way, evaporate_level, pheromone):
    for i in range(countJob):
        PTPmatrix[list_of_way[i]][i][1] = (1.0 - evaporate_level) * PTPmatrix[list_of_way[i]][i][1] + pheromone

def startAntCycle (jobMatrix, antCount):
  global_best_solution = None
  global_best_completion_time = float('inf')
  indexAnt = 0;
  # loop sebanyak semut yang ada
  while indexAnt < antCount:
    ant_ways = []
    # untuk cari tau apakah processor itu sudah menjalankan job
    proc_done = []
    # asumsi job dikerjakan urut sesuai index
    for i in range(countJob):
      # posibilitas semua jalan (untuk pembagi) (asumsi alpha dan beta = 1)
      Pall = 0.0
      for j in range(countProc):
        if j in proc_done:
          continue
        Pall += (1/(jobMatrix[j][i][0]))
      # array posibilitas ant akan menjalankan tugas yang mana
      Pant = []
      for j in range(countProc):
        if j in proc_done:
          continue
        if (jobMatrix[j][i][1] == 0):
          Pant.append((1/jobMatrix[j][i][0]) / Pall)
        else:
          Pant.append((jobMatrix[j][i][1] * (1/jobMatrix[j][i][0])) / Pall)
      # if i == 2:
      #   print(Pant)
      # untuk nentuin posibilitas ant e mau pergi kemana dulu per job e
      possibility_array = []
      minus_possibility = 0
      while minus_possibility < len(Pant):
        if (minus_possibility == 0):
           # jika pheromone 0/belum dilintasi ant apapun
          possibility_array.append(1.0)
        else:
          temp = minus_possibility
          possibility_array.append(1.0)
          while temp != 0:
            possibility_array[len(possibility_array) - 1] -= Pant[(len(Pant))-temp]
            temp -= 1
        minus_possibility +=1
      # apa yang dipilih ant
      # if i == 2:
      #   print(possibility_array)
      ant_choose = rndm.random()
      # if i == 2:
      #   print(ant_choose)
      index_possibility = 0
      if len(Pant) == 1:
        index_possibility = 0
      else:
        index_possibility = 1
      # buat nentuin dari probabilitas yang dipilih ant, dia kerjain job di processor mana
      while index_possibility < len(possibility_array):
        if (len(ant_ways) == countJob - 1):
          for x in range(countProc):
            if x not in proc_done:
              proc_done.append(x)
              ant_ways.append(x)
              break
          break
        if (ant_choose < possibility_array[len(possibility_array) - 1]):
          if (len(possibility_array) - 1) in proc_done:
            for x in range(countProc):
              if x not in proc_done:
                proc_done.append(x)
                ant_ways.append(x)
                break
            break
          proc_done.append(len(possibility_array) - 1)
          ant_ways.append(len(possibility_array) - 1)
          break
        if(ant_choose < possibility_array[index_possibility]):
          index_possibility+=1
        else:
          if (index_possibility - 1) in proc_done:
            for x in range(countProc):
              if x not in proc_done:
                proc_done.append(x)
                ant_ways.append(x)
                break
            break
          proc_done.append(index_possibility - 1)
          ant_ways.append(index_possibility - 1)
          break
    # print(proc_done)
    # ant_ways2 = []
    # for i in range(len(ant_ways)):
    #   ant_ways2.append([])
    #   ant_ways2[i] = ant_ways[i] + 1

    print(ant_ways)
    tempPhero = 0
    # buat ngitung semua jalur yang dilewati pheromone
    for i in range (countJob):
      tempPhero += jobMatrix[ant_ways[i]][i][0]
    # ngitung pheromone
    pheromone = 1/tempPhero

    # ngitung waktu selesai setiap jalurnya
    completion_times = [0] * countProc
    for job_index, processor_index in enumerate(ant_ways):
      completion_times[processor_index] += jobMatrix[processor_index][job_index][0]
    if (min(completion_times) == 0):
      current_completion_time = min(completion_times) + 1
    else:
      current_completion_time = min(completion_times)

    if current_completion_time < global_best_completion_time:
        global_best_completion_time = current_completion_time
        global_best_solution = ant_ways

    # buat nambah pheromone di jalan yang ant itu lewat
    updatePheromone(ant_ways, 0.2, pheromone)
    indexAnt+=1

  # buat kalau ada best solution, tambah pheromone di jalur itu
  if global_best_solution is not None:
      pheromone_increase = 1 / global_best_completion_time
      globalUpdate(global_best_solution, pheromone_increase)

startAntCycle(PTPmatrix, 100)

for i in range(countProc):
  print(PTPmatrix[i])

